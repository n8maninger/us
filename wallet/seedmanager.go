package wallet

import (
	"errors"
	"runtime"
	"sync"

	"gitlab.com/NebulousLabs/Sia/crypto"
	"gitlab.com/NebulousLabs/Sia/types"
	"lukechampine.com/us/ed25519"
)

const (
	// lookaheadLimit is the number of addresses monitored "in advance" to
	// prevent missing occurrences of owned addresses in the blockchain.
	lookaheadLimit = 20

	// parallelGenLimit is the cutoff before a parallel algorithm is used to
	// derive keys. Generating this many keys without a parallel algorithm
	// should take about 100ms.
	parallelGenLimit = 2000
)

// A SeedManager tracks the addresses derived from a Seed, and provides the
// UnlockConditions for the addresses it has generated.
type SeedManager struct {
	seed        Seed
	addrs       map[types.UnlockHash]uint64
	maxUseIndex uint64
}

// refreshLookahead ensures that s.addrs contains at least lookaheadLimit more
// addresses than s.maxUseIndex.
func (sm *SeedManager) refreshLookahead() {
	for index := uint64(len(sm.addrs)); index < sm.maxUseIndex+lookaheadLimit; index++ {
		sm.addrs[StandardAddress(sm.seed.PublicKey(index))] = index
	}
}

// parallelGen generates n addresses in parallel, using all available CPUs. This
// reduces startup time for SeedManagers that have derived lots of keys.
func (sm *SeedManager) parallelGen(n uint64) {
	addrs := make([]types.UnlockHash, n)
	numCPU := runtime.NumCPU()
	var wg sync.WaitGroup
	wg.Add(numCPU)
	for cpu := 0; cpu < numCPU; cpu++ {
		go func(offset uint64) {
			for i := offset; i < n; i += uint64(numCPU) {
				addrs[i] = StandardAddress(sm.seed.PublicKey(i))
			}
			wg.Done()
		}(uint64(cpu))
	}
	wg.Wait()

	for i, addr := range addrs {
		sm.addrs[addr] = uint64(i)
	}
}

// CurrentIndex returns the index that will be used to derive the next address.
func (sm *SeedManager) CurrentIndex() uint64 {
	return sm.maxUseIndex
}

// NextAddress returns a new address derived from the SeedManager's Seed.
func (sm *SeedManager) NextAddress() types.UnlockHash {
	addr := StandardAddress(sm.seed.PublicKey(sm.maxUseIndex))
	sm.maxUseIndex++
	sm.refreshLookahead()
	return addr
}

// Addresses returns all addresses generated by the SeedManager.
func (sm *SeedManager) Addresses() []types.UnlockHash {
	addrs := make([]types.UnlockHash, sm.maxUseIndex)
	for addr, index := range sm.addrs {
		if index < uint64(len(addrs)) {
			addrs[index] = addr
		}
	}
	return addrs
}

// AddressIndex returns the key index, or false if the address is not known to
// the SeedManager.
func (sm *SeedManager) AddressIndex(addr types.UnlockHash) (uint64, bool) {
	index, ok := sm.addrs[addr]
	return index, ok
}

// UnlockConditions returns the UnlockConditions associated with the specified
// address, or false if the address is not known to the SeedManager.
func (sm *SeedManager) UnlockConditions(addr types.UnlockHash) (types.UnlockConditions, bool) {
	index, ok := sm.addrs[addr]
	if !ok {
		return types.UnlockConditions{}, false
	}
	return StandardUnlockConditions(sm.seed.PublicKey(index)), true
}

// SecretKey returns the ed25519 private key associated with the specified
// address, or false if the address is not known to the SeedManager.
func (sm *SeedManager) SecretKey(addr types.UnlockHash) (ed25519.PrivateKey, bool) {
	index, ok := sm.addrs[addr]
	if !ok {
		return nil, false
	}
	return sm.seed.SecretKey(index), true
}

// OwnsAddress implements AddressOwner.
func (sm *SeedManager) OwnsAddress(addr types.UnlockHash) bool {
	index, ok := sm.addrs[addr]
	if ok && index > sm.maxUseIndex {
		sm.maxUseIndex = index
		sm.refreshLookahead()
	}
	return ok
}

// SignTransaction signs the specified transaction using keys owned by the
// SeedManager. If toSign is nil, SignTransaction will automatically add
// TransactionSignatures for each input owned by the SeedManager. If toSign is
// not nil, it a list of indices of TransactionSignatures already present in
// txn; SignTransaction will fill in the Signature field of each.
func (sm *SeedManager) SignTransaction(txn *types.Transaction, toSign []int) error {
	if len(toSign) == 0 {
		// lazy mode: add standard sigs for every input we own
		for _, input := range txn.SiacoinInputs {
			sk, ok := sm.SecretKey(input.UnlockConditions.UnlockHash())
			if !ok {
				continue
			}
			txnSig := StandardTransactionSignature(crypto.Hash(input.ParentID))
			AppendTransactionSignature(txn, txnSig, sk)
		}
		return nil
	}

	sigAddr := func(id crypto.Hash) (types.UnlockHash, bool) {
		for _, sci := range txn.SiacoinInputs {
			if crypto.Hash(sci.ParentID) == id {
				return sci.UnlockConditions.UnlockHash(), true
			}
		}
		for _, sfi := range txn.SiafundInputs {
			if crypto.Hash(sfi.ParentID) == id {
				return sfi.UnlockConditions.UnlockHash(), true
			}
		}
		for _, fcr := range txn.FileContractRevisions {
			if crypto.Hash(fcr.ParentID) == id {
				return fcr.UnlockConditions.UnlockHash(), true
			}
		}
		return types.UnlockHash{}, false
	}
	sign := func(i int) error {
		addr, ok := sigAddr(txn.TransactionSignatures[i].ParentID)
		if !ok {
			return errors.New("invalid id")
		}
		sk, ok := sm.SecretKey(addr)
		if !ok {
			return errors.New("can't sign")
		}
		txn.TransactionSignatures[i].Signature = sk.SignHash(txn.SigHash(i, types.ASICHardforkHeight+1))
		return nil
	}

	for _, sigIndex := range toSign {
		if err := sign(sigIndex); err != nil {
			return err
		}
	}
	return nil
}

// NewSeedManager initializes a SeedManager using the provided seed and
// maxUseIndex, which is the number of keys previously derived from the Seed.
// Those keys must be re-derived before NewSeedManager returns, so
// NewSeedManager may take a while for large values of maxUseIndex.
func NewSeedManager(seed Seed, maxUseIndex uint64) *SeedManager {
	sm := &SeedManager{
		seed:        seed,
		addrs:       make(map[types.UnlockHash]uint64, maxUseIndex+lookaheadLimit),
		maxUseIndex: maxUseIndex,
	}
	if maxUseIndex > parallelGenLimit {
		sm.parallelGen(maxUseIndex)
	}
	sm.refreshLookahead()
	return sm
}
